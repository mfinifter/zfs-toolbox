#! /usr/bin/env python2.7

#  This program is free software. It comes without any warranty, to
#  the extent permitted by applicable law. You can redistribute it
#  and/or modify it under the terms of the Do What The Fuck You Want
#  To Public License, Version 2, as published by Sam Hocevar. See
#  http://sam.zoy.org/wtfpl/COPYING for more details.

import argparse
import subprocess
import sys
import os

QUIET = False

def main():
    parser = argparse.ArgumentParser(description='Destroy a set of snapshots, as specified by the arguments.')
    parser.add_argument('-n', '--dry-run', help="don't actually destroy anything.", default=False, action='store_true')
    parser.add_argument('-q', '--quiet', help="don't list snapshots that are to be destroyed", default=False, action='store_true')
    parser.add_argument('--yes', help="don't ask for confirmation before destroying", default=False, action='store_true')
    parser.add_argument('dataset', help='the dataset')
    parser.add_argument('snapshot', help='the name of the snapshot')

    # A group for required command argument.
    group = parser.add_argument_group('command (required)')
    group.add_argument('-u', '--upto', help="destroy all snapshots up to and including the named snapshot (and descendant snapshots, if combined with -r)", default=False, action='store_true')
    group.add_argument('-r', '--recursive', help="destroy snapshots on all descendant datasets with the same snapshot name", default=False, action='store_true')

    args = vars(parser.parse_args())
    dataset = args['dataset']
    snapshot = args['snapshot']
    dry_run = args['dry_run']
    upto = args['upto']
    recursive = args['recursive']
    noconfirm = args['yes']
    quiet = args['quiet']

    global QUIET
    QUIET = quiet

    # We require you to specify -u, -r, or both.
    if not upto and not recursive:
        arg_error(parser, "you must specify -u, -r, or both")

    # We have not implemented -r yet, so -r is currently required
    # TODO after implementing -r, remove this check
    if recursive:
        arg_error(parser, "-r is not yet implemented")

    # If '-u' was specified, for each dataset (that is the named dataset and any
    # descendants, if '-r' was specified), we need to:
    #   - Get the snapshots on the given dataset, up to the named snapshot
    #   - List the snapshots that will be destroyed (if not '-q')
    #   - Get interactive confirmation from the user (if not '--yes')
    #   - Destroy the snapshots
    if upto:
        cmd = "/sbin/zfs list -H -t snapshot -s creation -o name -d 1 " + dataset
        output = exec_in_shell(cmd)
        snaps = output.split('\n')
        try:
            index = snaps.index("%s@%s" % (dataset, snapshot))
            snaps_to_destroy = snaps[0:index+1]
            msg("The following snapshots will be destroyed:")
            for snap in snaps_to_destroy:
                msg("    " + snap)

            choice = 'n'
            if noconfirm:
                choice = 'y'
            else:
                print "Proceed (y/n)?",
                choice = raw_input().lower()

            if choice == 'y':
                destroy_snapshots(snaps_to_destroy, dry_run)
            else:
                msg("No snapshots destroyed. Exiting.")
        except ValueError:
            print("Snapshot %s@%s not found. Exiting." % (dataset, snapshot))

def arg_error(parser, msg):
    parser.print_usage()
    print(os.path.basename(__file__) + ": error: " + msg)
    sys.exit()

def msg(message):
    if not QUIET:
        print(message)


def destroy_snapshots(snapshots, dry_run):
    msg("Destroying snapshots.")
    for snap in snapshots:
        destroy_snapshot(snap, dry_run)
    msg("Finished destroying snapshots. Exiting.")

def destroy_snapshot(snapshot, dry_run):
    cmd = "/sbin/zfs destroy %s" % snapshot
    msg("Running command: %s" % cmd)
    if not dry_run:
        exec_in_shell(cmd)

def exec_in_shell(cmd):
    try:
        return subprocess.check_output(cmd.split())
    except subprocess.CalledProcessError, e:
        # Non-zero exit code, but we don't really care
        return e.output

if __name__ == '__main__':
    main()

